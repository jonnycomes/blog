[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jonny's Blog",
    "section": "",
    "text": "Quantum Fourier transform\n\n\n\n\n\n\n\nquantum\n\n\nqiskit\n\n\nQFT\n\n\n\n\n\n\n\n\n\n\n\nDec 2, 2022\n\n\nJonny Comes\n\n\n\n\n\n\n\n\nQiskit: getting started\n\n\n\n\n\n\n\nquantum\n\n\nqiskit\n\n\n\n\n\n\n\n\n\n\n\nNov 28, 2022\n\n\nJonny Comes\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hello! My name is Jonny. I’m an Assistant Professor of Mathematics at The College of Idaho. This is a place for me to write about various math and cs stuff I’m thinking about.\nThis blog was made with quarto."
  },
  {
    "objectID": "posts/post-notebook/Untitled.html",
    "href": "posts/post-notebook/Untitled.html",
    "title": "Hello Title",
    "section": "",
    "text": "Hello\n\\(x+1=3\\) and \\[x+4=\\int x~dx\\]"
  },
  {
    "objectID": "posts/post-notebook/index.html",
    "href": "posts/post-notebook/index.html",
    "title": "matplotlib demo",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure 1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "posts/first-qiskit/First-qiskit.html",
    "href": "posts/first-qiskit/First-qiskit.html",
    "title": "Qiskit: getting started",
    "section": "",
    "text": "from qiskit import QuantumCircuit\n\nFirst, we create a 3-qubit quantum circuit:\n\nqc = QuantumCircuit(3)\n\nNow, let’s add some gates:\n\nqc.x(0)\nqc.h(2)\nqc.draw()\n\n     ┌───┐\nq_0: ┤ X ├\n     └───┘\nq_1: ─────\n     ┌───┐\nq_2: ┤ H ├\n     └───┘"
  },
  {
    "objectID": "posts/first-qiskit/index.html",
    "href": "posts/first-qiskit/index.html",
    "title": "Qiskit: getting started",
    "section": "",
    "text": "Qiskit is an open source software development kit (SDK) for working with quantum computation. There are several excellent tutorials for getting started with qiskit, as well as loads of great documentation you can find at qiskit.org. The following walks through some of the very basics including how to create quantum circuits, simulate measurments, and work with state vectors."
  },
  {
    "objectID": "posts/first-qiskit/index.html#creating-quantum-circuits",
    "href": "posts/first-qiskit/index.html#creating-quantum-circuits",
    "title": "Qiskit: getting started",
    "section": "Creating quantum circuits",
    "text": "Creating quantum circuits\n\nfrom qiskit import QuantumCircuit\n\nFirst, we create a 3-qubit quantum circuit:\n\nqc = QuantumCircuit(3)\n\nNext, we add some gates and draw the resulting circuit:\n\nqc.x(0)\nqc.h(2)\nqc.cx(0,2)\nqc.cx(1,2)\nqc.draw(output='mpl')"
  },
  {
    "objectID": "posts/first-qiskit/index.html#measuring",
    "href": "posts/first-qiskit/index.html#measuring",
    "title": "Qiskit: getting started",
    "section": "Measuring",
    "text": "Measuring\nWe can simulate a measurement, but first we need to import a simulator:\n\nfrom qiskit.providers.aer import QasmSimulator\n\nsimulator = QasmSimulator()\n\nNow, to measure we use a circuit having both a quantum and classical register:\n\ncircuit = QuantumCircuit(3, 3)\n\nNow, let’s add some gates including some measuments:\n\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.cx(0, 2)\ncircuit.measure([0,1,2], [0,1,2])\ncircuit.draw()\n\n     ┌───┐             ┌─┐   \nq_0: ┤ H ├──■────■─────┤M├───\n     └───┘┌─┴─┐  │  ┌─┐└╥┘   \nq_1: ─────┤ X ├──┼──┤M├─╫────\n          └───┘┌─┴─┐└╥┘ ║ ┌─┐\nq_2: ──────────┤ X ├─╫──╫─┤M├\n               └───┘ ║  ║ └╥┘\nc: 3/════════════════╩══╩══╩═\n                     1  0  2 \n\n\nNext, we simulate and count the results:\n\njob = simulator.run(circuit, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circuit)\nprint(counts)\n\n{'000': 506, '111': 494}\n\n\nWe can plot the results using qiskits built in visualization:\n\nfrom qiskit.visualization import plot_histogram\n\nplot_histogram(counts)"
  },
  {
    "objectID": "posts/first-qiskit/index.html#measurements",
    "href": "posts/first-qiskit/index.html#measurements",
    "title": "Qiskit: getting started",
    "section": "Measurements",
    "text": "Measurements\nWe can simulate a measurement, but first we need to import a simulator:\n\nfrom qiskit.providers.aer import QasmSimulator\n\nsimulator = QasmSimulator()\n\n\nMeasure using a classical register explicitly\nOne way to measure is to use a circuit having both a quantum and classical register:\n\ncircuit = QuantumCircuit(3, 3)\n\nNow, let’s add some gates including some measuments:\n\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.cx(0, 2)\ncircuit.measure([0,1,2], [0,1,2])\ncircuit.draw(output='mpl')\n\n\n\n\nNext, we simulate and count the results:\n\njob = simulator.run(circuit, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circuit)\nprint(counts)\n\n{'000': 497, '111': 503}\n\n\nWe can plot the results using qiskits built in visualization:\n\nfrom qiskit.visualization import plot_histogram\n\nplot_histogram(counts)\n\n\n\n\n\n\nUsing the measure_all() method\nAlternatively, if we want to measure all the qubits we can use the measure_all() method:\n\ncircuit = QuantumCircuit(3)\n\nNow, let’s add some gates including some measuments:\n\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.cx(0, 2)\ncircuit.measure_all()\ncircuit.draw(output='mpl')\n\n\n\n\nWe should see similar results:\n\njob = simulator.run(circuit, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circuit)\nprint(counts)\n\n{'111': 502, '000': 498}\n\n\nOf course, this will only work if we want to measure all the qubits in the output state of the circuit."
  },
  {
    "objectID": "posts/first-qiskit/index.html#circuit-orientation",
    "href": "posts/first-qiskit/index.html#circuit-orientation",
    "title": "Qiskit: getting started",
    "section": "Circuit orientation",
    "text": "Circuit orientation\nQiskit orients circuits so that the qubits \\(q_0, q_1,\\ldots, q_{n-1}\\) labelling the circut from top to bottom correspond to the input state \\(|q_{n-1}\\cdots q_1q_0\\rangle\\). To see this, let’s create a simple gate that maps \\(|000\\rangle\\mapsto|100\\rangle\\).\n\ncirc = QuantumCircuit(3)\ncirc.x(2)\ncirc.measure_all()\ncirc.draw(output='mpl')\n\n\n\n\nTo see that the circuit above does the trick, let’s measure:\n\njob = simulator.run(circ, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circ)\nprint(counts)\n\n{'100': 1000}\n\n\nI prefer the flipped orientation where the top qubit in the circuit corresponds to the left qubit in the tensor product. To have qiskit draw circuits with my prefered orientation, we simply pass reverse_bits=True to the draw() method:\n\ncirc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\njob = simulator.run(circ, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circ)\nprint(counts)\n\n{'100': 1000}"
  },
  {
    "objectID": "posts/first-qiskit/index.html#state-vectors",
    "href": "posts/first-qiskit/index.html#state-vectors",
    "title": "Qiskit: getting started",
    "section": "State vectors",
    "text": "State vectors\nWe can use qiskits Statevector object work with \\(n\\)-qubit states.\n\nfrom qiskit.quantum_info import Statevector\n\nFor example, the following creates the state \\(|7\\rangle\\) for a 4-qubit register:\n\nstate = Statevector.from_int(7, 2**4)\nstate.draw('latex')\n\n\\[ |0111\\rangle\\]\n\n\nWe can run this state through a quantum circuit as in the following example:\n\nqc = QuantumCircuit(4)\nqc.h(1)\nqc.cx(0, 2)\nqc.swap(1,3)\nqc.draw(reverse_bits=True)\n\n                  \nq_3: ───────────X─\n          ┌───┐ │ \nq_2: ─────┤ X ├─┼─\n     ┌───┐└─┬─┘ │ \nq_1: ┤ H ├──┼───X─\n     └───┘  │     \nq_0: ───────■─────\n                  \n\n\n\nstate = state.evolve(qc)\nstate.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{2} |0001\\rangle- \\frac{\\sqrt{2}}{2} |1001\\rangle\\]"
  },
  {
    "objectID": "posts/first-qiskit/index.html#state-vectors-of-integers",
    "href": "posts/first-qiskit/index.html#state-vectors-of-integers",
    "title": "Qiskit: getting started",
    "section": "State vectors of integers",
    "text": "State vectors of integers\nWe can use qiskits Statevector object work with \\(n\\)-qubit states.\n\nfrom qiskit.quantum_info import Statevector\n\nFor example, the following creates the state \\(|7\\rangle\\) for a 4-qubit register:\n\nstate = Statevector.from_int(7, 2**4)\nstate.draw('latex')\n\n\\[ |0111\\rangle\\]\n\n\nWe can visualize the state \\(|7\\rangle\\) on a register of Bloch spheres as follows:\n\nfrom qiskit.visualization import plot_bloch_multivector\n\nplot_bloch_multivector(state)\n\n\n\n\nWe can run this state through a quantum circuit as in the following example:\n\nqc = QuantumCircuit(4)\nqc.h(1)\nqc.h(2)\nqc.cx(0, 2)\nqc.swap(1,3)\nqc.draw(reverse_bits=True)\n\n                  \nq_3: ───────────X─\n     ┌───┐┌───┐ │ \nq_2: ┤ H ├┤ X ├─┼─\n     ├───┤└─┬─┘ │ \nq_1: ┤ H ├──┼───X─\n     └───┘  │     \nq_0: ───────■─────\n                  \n\n\n\nstate = state.evolve(qc)\nstate.draw('latex')\n\n\\[- \\frac{1}{2} |0001\\rangle+\\frac{1}{2} |0101\\rangle+\\frac{1}{2} |1001\\rangle- \\frac{1}{2} |1101\\rangle\\]\n\n\nFinally, let’s look at this state using Bloch spheres:\n\nplot_bloch_multivector(state)"
  },
  {
    "objectID": "posts/first-qiskit/index.html#the-bloch-sphere",
    "href": "posts/first-qiskit/index.html#the-bloch-sphere",
    "title": "Qiskit: getting started",
    "section": "The Bloch sphere",
    "text": "The Bloch sphere\n\nfrom qiskit.visualization import plot_bloch_vector\n\n\nplot_bloch_vector([1,0,0])"
  },
  {
    "objectID": "posts/first-qiskit/index.html#state-vectors-and-bloch-spheres",
    "href": "posts/first-qiskit/index.html#state-vectors-and-bloch-spheres",
    "title": "Qiskit: getting started",
    "section": "State vectors and Bloch spheres",
    "text": "State vectors and Bloch spheres\nWe can use qiskits Statevector object work with \\(n\\)-qubit states.\n\nfrom qiskit.quantum_info import Statevector\n\nFor example, the following creates the state \\(|7\\rangle\\) for a 4-qubit register:\n\nstate = Statevector.from_int(7, 2**4)\nstate.draw('latex')\n\n\\[ |0111\\rangle\\]\n\n\nWe can visualize the state \\(|7\\rangle\\) on a register of Bloch spheres as follows:\n\nfrom qiskit.visualization import plot_bloch_multivector\n\nplot_bloch_multivector(state, reverse_bits=True)\n\n\n\n\nWe can run this state through a quantum circuit as in the following example:\n\nqc = QuantumCircuit(4)\nqc.h(1)\nqc.h(2)\nqc.cx(0, 2)\nqc.swap(1,3)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nstate = state.evolve(qc)\nstate.draw('latex')\n\n\\[- \\frac{1}{2} |0001\\rangle+\\frac{1}{2} |0101\\rangle+\\frac{1}{2} |1001\\rangle- \\frac{1}{2} |1101\\rangle\\]\n\n\nFinally, let’s look at this state using Bloch spheres:\n\nplot_bloch_multivector(state, reverse_bits=True)"
  },
  {
    "objectID": "posts/quantum-fourier-transform/index.html",
    "href": "posts/quantum-fourier-transform/index.html",
    "title": "Quantum Fourier transform",
    "section": "",
    "text": "The Fourier transform is a beautiful function with many important applications in and outside of mathematics. There is a wonderful introduction to the Fourier transform by 3 Blue 1 Brown that is well worth watching. The following is a description of the quantum Fourier transform (QFT). After defining a closed formula for QFT, I will explain how to build the QFT circuit using a recursive formula. In the end, I will prove that the closed formula and recursive formula agree. All the quantum circuits in this post are created with qiskit.\n\n\nCode\nfrom qiskit import QuantumCircuit\nfrom math import pi\n\n\n\n\nFix a positive integer \\(n\\) and let \\(N=2^n\\) denote the dimension of the \\(n\\)-qubit state space. In what follows, given an integer \\(0\\leq a< N\\) we write \\(|a\\rangle\\) for the state vector corresponding to the \\(a\\)-th standard basis vector. In other words, \\(|a\\rangle=|a_{n-1}\\cdots a_1a_0\\rangle\\) where each \\(a_i\\in\\{0,1\\}\\) and \\(a=\\sum\\limits_{k=0}^{n-1}a_k2^k\\). For example, when \\(n=3\\) we have\n\\[\\begin{align*}\n    |0\\rangle &= |000\\rangle, &\n    |1\\rangle &= |001\\rangle, \\\\\n    |2\\rangle &= |010\\rangle, &\n    |3\\rangle &= |011\\rangle, \\\\\n    |4\\rangle &= |100\\rangle, &\n    |5\\rangle &= |101\\rangle, \\\\\n    |6\\rangle &= |110\\rangle, &\n    |7\\rangle &= |111\\rangle. \\\\\n\\end{align*}\\]\nThis is just the usual binary representation of integers, but with qubits. I like to refer to \\(|a\\rangle\\) as the (standard) \\(n\\)-qubit representation of the integer \\(a\\).\n\n\n\nThe quantum Fourier transform \\(QFT_n\\) is define on the \\(n\\)-qubit representation of \\(a\\) by \\[\nQFT_n|a\\rangle = \\dfrac{1}{\\sqrt{N}}\\sum_{b=0}^{N-1}e^{2\\pi i a b/N}|b\\rangle.\n\\tag{1}\\]\n\n\nWhen \\(n=1\\) (so that \\(N=2\\)) the closed formula above shows that \\(QFT_1\\) maps\n\\[\\begin{align*}\n    |0\\rangle & \\mapsto \\dfrac{1}{\\sqrt{2}}\\left(|0\\rangle + |1\\rangle\\right)\\\\\n    |1\\rangle & \\mapsto \\dfrac{1}{\\sqrt{2}}\\left(|0\\rangle - |1\\rangle\\right)\n\\end{align*}\\]\nThis is the same mapping given by our beloved Hadamard gate, so \\(QFT_1=H\\).\n\n\n\nWhen \\(n=2\\) (so that \\(N=4\\)) the closed formula shows that \\(QFT_2\\) maps\n\\[\\begin{align*}\n    |0\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle + |1\\rangle + |2\\rangle + |3\\rangle\\right)\\\\\n    |1\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle + i|1\\rangle -|2\\rangle - i|3\\rangle\\right)\\\\\n    |2\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle - |1\\rangle + |2\\rangle - |3\\rangle\\right)\\\\\n    |3\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle - i|1\\rangle - |2\\rangle + i|3\\rangle\\right)\n\\end{align*} \\tag{2}\\]\nEquivalently, expanding the above states into qubits we see \\(QFT_2\\) maps\n\\[\\begin{align*}\n    |00\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle\\right)\\\\\n    |01\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle + i|01\\rangle -|10\\rangle - i|11\\rangle\\right)\\\\\n    |10\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle - |01\\rangle + |10\\rangle - |11\\rangle\\right)\\\\\n    |11\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle - i|01\\rangle - |10\\rangle + i|11\\rangle\\right)\n\\end{align*} \\tag{3}\\]"
  },
  {
    "objectID": "posts/quantum-fourier-transform/index.html#recursive-definition-of-qft",
    "href": "posts/quantum-fourier-transform/index.html#recursive-definition-of-qft",
    "title": "Quantum Fourier transform",
    "section": "Recursive definition of QFT",
    "text": "Recursive definition of QFT\n\nRotations\n\n\nSwapping\n\n\nA recursive formula for QFT\n\n\nThe QFT circuit\n\n\nProof that closed and recursive formulas agree"
  },
  {
    "objectID": "posts/quantum-fourier-transform/index.html#the-qft-circuit",
    "href": "posts/quantum-fourier-transform/index.html#the-qft-circuit",
    "title": "Quantum Fourier transform",
    "section": "The QFT circuit",
    "text": "The QFT circuit\n\nCP-chains\nOne of the building blocks (subcircuits) of the QFT circuit consists of a composition of controlled phase gates. We will call these subcircuits CP-chains. In the following we will describe these CP-chains and give an explicit formula for how they map qubit states.\n\nPhase gates\nWe will write \\(P_\\phi\\) for the P-gate, which depends on a parameter \\(\\phi\\), that maps qubits as follows\n\\[\\begin{align*}\n    |0\\rangle & \\mapsto |0\\rangle\\\\\n    |1\\rangle & \\mapsto e^{\\phi i} |1\\rangle\n\\end{align*}\\] In other words, a P-gate applies a relative phase change to the \\(|1\\rangle\\) component of a qubit. If you prefer to describe gates by matrices, then \\[P_\\phi=\\begin{pmatrix}\n    1 & 0\\\\\n    0 & e^{\\phi i}\n\\end{pmatrix}\\]\nNote that we can get a little clever and write the P-gate mapping as \\[P_\\phi: |q\\rangle \\mapsto e^{q\\phi i}|q\\rangle\\] where \\(q\\in\\{0, 1\\}\\). The P-gate \\(P_{\\pi/2}\\) is pictured as follows:\n\n\nCode\nqc = QuantumCircuit(1)\nqc.p(pi/2, 0)\nqc.draw(output='mpl')\n\n\n\n\n\n\n\nControlled phase gates\nUsing the cleverness above, a controlled P-gate will map \\[CP_\\phi: |q_1q_0\\rangle \\mapsto e^{q_1q_0\\phi i}|q_1q_0\\rangle.\\]\nThe controlled P-gate \\(CP_{\\pi/2}\\) is drawn as follows:\n\n\nCode\nqc = QuantumCircuit(2)\nqc.cp(pi/2, 0, 1)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\n\n\nA chain of controlled phase gates\nSuppose we are concerned with a \\((n+1)\\)-qubit state space. Consider \\(n\\) CP-gates: \\(CP_{\\pi/2^k}\\) between the \\(n\\)-th and \\((n-k)\\)-th qubit for each \\(1\\leq k\\leq n\\). For example, when \\(n=4\\) the composition of these four CP-gates is the following:\n\n\nCode\ndef cpc(n):\n    qc = QuantumCircuit(n, name=f'  CPC  ')\n    for k in range(1, n):\n        qc.cp(pi/(2**k), n-1, n-1-k)\n    return qc\n\ncpc(5).draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nI don’t know a standard name for the circuit above, so I’ll refer to the composition of these \\(n\\) CP-gates as the CP-chain, denoted \\(CPC_{n+1}\\). For example, the circuit drawn above is \\(CPC_5\\). Based on the mapping of \\(CP_\\phi\\) given above, it follows that the CP-chain maps \\(|a\\rangle=|a_n\\cdots a_1a_0\\rangle\\), the \\((n+1)\\)-qubit representation of an integer \\(0\\leq a< 2^{n+1}\\), as follows: \\[CPC_{n+1}:|a_na_{n-1}\\cdots a_1a_0\\rangle \\mapsto \\prod\\limits_{k=1}^ne^{\\frac{\\pi i\na_na_{n-k}}{2^k}}|a_na_{n-1}\\cdots a_1a_0\\rangle\\] To simplify the expression above, it will be useful to let \\(a'\\) denote the integer with \\(n\\)-qubit representation \\(|a'\\rangle=|a_{n-1}\\cdots a_1a_0\\rangle\\) so that \\(|a\\rangle=|a_n\\rangle\\otimes|a'\\rangle\\). With this notation, the amplitude above simplifies as \\[\\begin{align*}\n    \\prod\\limits_{k=1}^ne^{\\frac{\\pi i a_na_{n-k}}{2^k}}\n    & =e^{\\sum_{k=1}^n\\frac{\\pi i a_na_{n-k}}{2^k}} \\\\\n    & =e^{\\frac{\\pi i a_n}{2^n}\\sum_{k=1}^na_{n-k}2^{n-k}} \\\\\n    & =e^{\\frac{\\pi i a_n}{2^n}\\sum_{k=0}^{n-1}a_{k}2^{k}} \\\\\n    & =e^{\\frac{\\pi i a_na'}{2^n}}. \\\\\n\\end{align*}\\] Thus, the CP-chain mapping can be written as \\[\nCPC_{n+1}:|a_n\\rangle\\otimes|a'\\rangle \\mapsto e^{\\frac{\\pi i a_na'}{2^n}} |a_n\\rangle\\otimes|a'\\rangle.\n\\tag{4}\\]\n\n\n\nReverse circuits\nReversing the order of the qubits is another component of the QFT circuit. Reversing qubits can easily be accomplished using swap gates. The swap gate, pictured below, maps \\(|q_1q_0\\rangle\\to|q_0q_1\\rangle\\).\n\n\nCode\nqc = QuantumCircuit(2)\nqc.swap(0, 1)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nWe let \\(Rev_n\\) for the \\(n\\)-qubit gate that reverses the qubit order. For example, \\(Rev_2\\) is the swap gate above. To obtain \\(Rev_n\\), one simply swaps the first and last qubit, the second and second to last qubit, and so on. For example, the following is \\(Rev_7\\):\n\n\nCode\ndef rev(n):\n    qc = QuantumCircuit(n, name=f'  Rev  ')\n    for i in range(n//2):\n        qc.swap(i, n-i-1)\n    return qc\n\nrev(7).draw(output='mpl', reverse_bits=True)\n\n\n\n\n\n\n\nA recursive formula for QFT\nWe are now in position to state recursive formula for the QFT that will allow use to build the QFT circuits:\n\\[\nQFT_{n+1} = Rev_{n+1}\\circ (I\\otimes (Rev_n\\circ QFT_n))\\circ CPC_{n+1}\\circ(H\\otimes I^{\\otimes n})\n\\tag{5}\\]\nThe formula above may be easier to visualize using circuits. Here is the recursively defined QFT circuit:\n\n\nCode\ndef qft(n):\n    qc = QuantumCircuit(n, name=f'  QFT  ')\n    qc.h(n-1)\n    if n == 1:\n        return qc\n    qc.append(cpc(n), range(n))\n    qc.append(qft(n-1), range(n-1))\n    qc.append(rev(n-1), range(n-1))\n    qc.append(rev(n), range(n))\n\n    return qc\n\nqft(5).draw(output='mpl', reverse_bits=True, style={\n    \"displaycolor\": {\n        \"  Rev  \": [ # gate name\n            \"#555555\", # box color (grey)\n            \"#FFFFFF\" # box text color (white)\n        ],\n        \"  QFT  \": [ # gate name\n            \"#da1e28\", # box color (red)\n            \"#FFFFFF\" # box text color (white)\n        ],\n    }})\n\n\n\n\n\n\n\nThe QFT circuit\nStarting with \\(QFT_1=H\\), the recursive formula 5 can be used to build all the QFT circuits in terms of H, CP, and swap gates. For example, here is \\(QFT_2\\):\n\n\nCode\nqc = QuantumCircuit(2)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,1)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nPlugging this into the recursive formula 5 gives us \\(QFT_3\\). After simplifying (Rev-gates are their own inverses) and expanding the CPC and Rev gates into CP and swap gates, we get the following for \\(QFT_3\\):\n\n\nCode\nqc = QuantumCircuit(3)\nqc.h(2)\nqc.cp(pi/2, 2, 1)\nqc.cp(pi/4, 2, 0)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,2)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\nSimilarly, we can plug the QFT-circuit above into the recursive formula 5 and (after expanding and simplifying) get \\(QFT_4\\) in terms of H, CP, and swap gates:\n\n\nCode\nqc = QuantumCircuit(4)\nqc.h(3)\nqc.cp(pi/2, 3, 2)\nqc.cp(pi/4, 3, 1)\nqc.cp(pi/8, 3, 0)\nqc.h(2)\nqc.cp(pi/2, 2, 1)\nqc.cp(pi/4, 2, 0)\nqc.h(1)\nqc.cp(pi/2, 1, 0)\nqc.h(0)\nqc.swap(0,3)\nqc.swap(1,2)\nqc.draw(output='mpl', reverse_bits=True)\n\n\n\n\n\n\n\nA couple QFT computations with qiskit\nIn the code blocks above, the recursive formula 5 was used to create the QFT-circuit with qiskit. The following shows how to perform QFT calculations with qiskit. First, lets check that our circuit correctly computes \\(QFT_2|3\\rangle\\) (compare with 2 and 3).\n\nfrom qiskit.quantum_info import Statevector\nn = 2\na = 3\nstate_in = Statevector.from_int(a, 2**n)\nstate_out = state_in.evolve(qft(n))\nstate_out.draw('latex')\n\n\\[\\frac{1}{2} |00\\rangle- \\frac{i}{2} |01\\rangle- \\frac{1}{2} |10\\rangle+\\frac{i}{2} |11\\rangle\\]\n\n\nFor a slightly larger computation, let’s compute \\(QFT_3|7\\rangle\\):\n\nn = 3\na = 7\nstate_in = Statevector.from_int(a, 2**n)\nstate_out = state_in.evolve(qft(n))\nstate_out.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{4} |000\\rangle+ (\\frac{1}{4} - \\frac{i}{4}) |001\\rangle- \\frac{\\sqrt{2} i}{4} |010\\rangle+ (- \\frac{1}{4} - \\frac{i}{4}) |011\\rangle- \\frac{\\sqrt{2}}{4} |100\\rangle+ (- \\frac{1}{4} + \\frac{i}{4}) |101\\rangle+\\frac{\\sqrt{2} i}{4} |110\\rangle+ (\\frac{1}{4} + \\frac{i}{4}) |111\\rangle\\]"
  },
  {
    "objectID": "posts/quantum-fourier-transform/index.html#proof-that-closed-and-recursive-formulas-agree",
    "href": "posts/quantum-fourier-transform/index.html#proof-that-closed-and-recursive-formulas-agree",
    "title": "Quantum Fourier transform",
    "section": "Proof that closed and recursive formulas agree",
    "text": "Proof that closed and recursive formulas agree"
  },
  {
    "objectID": "posts/quantum-fourier-transform/index.html#proof-that-closed-and-recursive-formulas-for-qft-agree",
    "href": "posts/quantum-fourier-transform/index.html#proof-that-closed-and-recursive-formulas-for-qft-agree",
    "title": "Quantum Fourier transform",
    "section": "Proof that closed and recursive formulas for QFT agree",
    "text": "Proof that closed and recursive formulas for QFT agree"
  },
  {
    "objectID": "posts/quantum-fourier-transform/index.html#the-quantum-fourier-transform",
    "href": "posts/quantum-fourier-transform/index.html#the-quantum-fourier-transform",
    "title": "Quantum Fourier transform",
    "section": "The quantum Fourier transform",
    "text": "The quantum Fourier transform\n\n\\(n\\)-qubit representations of integers\nFix a positive integer \\(n\\) and let \\(N=2^n\\) denote the dimension of the \\(n\\)-qubit state space. In what follows, given an integer \\(a\\in\\{0,1,\\ldots,N-1\\}\\) we write \\(|a\\rangle\\) for the state vector corresponding to the \\(a\\)-th standard basis vector. In other words, \\(|a\\rangle=|a_{n-1}\\cdots a_1a_0\\rangle\\) where each \\(a_i\\in\\{0,1\\}\\) and \\(a=\\sum\\limits_{k=0}^{n-1}a_k2^k\\). For example, when \\(n=3\\) we have\n\\[\\begin{align*}\n    |0\\rangle &= |000\\rangle, &\n    |1\\rangle &= |001\\rangle, \\\\\n    |2\\rangle &= |010\\rangle, &\n    |3\\rangle &= |011\\rangle, \\\\\n    |4\\rangle &= |100\\rangle, &\n    |5\\rangle &= |101\\rangle, \\\\\n    |6\\rangle &= |110\\rangle, &\n    |7\\rangle &= |111\\rangle. \\\\\n\\end{align*}\\]\nThis is just the usual binary representation of integers, but with qubits. I like to refer to \\(|a\\rangle\\) as the (standard) \\(n\\)-qubit representation of the integer \\(a\\).\n\n\nA closed formula for QFT\nThe quantum Fourier transform \\(QFT_n\\) is define on the \\(n\\)-qubit representation of \\(a\\) by \\[\nQFT_n|a\\rangle = \\dfrac{1}{\\sqrt{N}}\\sum_{b=0}^{N-1}e^{2\\pi i a b/N}|b\\rangle.\n\\tag{1}\\]\n\nExample: \\(QFT_1\\)\nWhen \\(n=1\\) (so that \\(N=2\\)) the closed formula above shows that \\(QFT_1\\) maps\n\\[\\begin{align*}\n    |0\\rangle & \\mapsto \\dfrac{1}{\\sqrt{2}}\\left(|0\\rangle + |1\\rangle\\right)\\\\\n    |1\\rangle & \\mapsto \\dfrac{1}{\\sqrt{2}}\\left(|0\\rangle - |1\\rangle\\right)\n\\end{align*}\\]\nThis is the same mapping given by our beloved Hadamard gate, so \\(QFT_1=H\\).\n\n\nExample: \\(QFT_2\\)\nWhen \\(n=2\\) (so that \\(N=4\\)) the closed formula shows that \\(QFT_2\\) maps\n\\[\\begin{align*}\n    |0\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle + |1\\rangle + |2\\rangle + |3\\rangle\\right)\\\\\n    |1\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle + i|1\\rangle -|2\\rangle - i|3\\rangle\\right)\\\\\n    |2\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle - |1\\rangle + |2\\rangle - |3\\rangle\\right)\\\\\n    |3\\rangle & \\mapsto \\dfrac{1}{2}\\left(|0\\rangle - i|1\\rangle - |2\\rangle + i|3\\rangle\\right)\n\\end{align*}\\]\nEquivalently, expanding the above states into qubits we see \\(QFT_2\\) maps\n\\[\\begin{align*}\n    |00\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle\\right)\\\\\n    |01\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle + i|01\\rangle -|10\\rangle - i|11\\rangle\\right)\\\\\n    |10\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle - |01\\rangle + |10\\rangle - |11\\rangle\\right)\\\\\n    |11\\rangle & \\mapsto \\dfrac{1}{2}\\left(|00\\rangle - i|01\\rangle - |10\\rangle + i|11\\rangle\\right)\n\\end{align*}\\]"
  },
  {
    "objectID": "posts/quantum-fourier-transform/index.html#n-qubit-representations-of-integers",
    "href": "posts/quantum-fourier-transform/index.html#n-qubit-representations-of-integers",
    "title": "Quantum Fourier transform",
    "section": "\\(n\\)-qubit representations of integers",
    "text": "\\(n\\)-qubit representations of integers\nFix a positive integer \\(n\\) and let \\(N=2^n\\) denote the dimension of the \\(n\\)-qubit state space. In what follows, given an integer \\(a\\in\\{0,1,\\ldots,N-1\\}\\) we write \\(|a\\rangle\\) for the state vector corresponding to the \\(a\\)-th standard basis vector. In other words, \\(|a\\rangle=|a_{n-1}\\cdots a_1a_0\\rangle\\) where each \\(a_i\\in\\{0,1\\}\\) and \\(a=\\sum\\limits_{k=0}^{n-1}a_k2^k\\). For example, when \\(n=3\\) we have\n\\[\\begin{align*}\n    |0\\rangle &= |000\\rangle, &\n    |1\\rangle &= |001\\rangle, \\\\\n    |2\\rangle &= |010\\rangle, &\n    |3\\rangle &= |011\\rangle, \\\\\n    |4\\rangle &= |100\\rangle, &\n    |5\\rangle &= |101\\rangle, \\\\\n    |6\\rangle &= |110\\rangle, &\n    |7\\rangle &= |111\\rangle. \\\\\n\\end{align*}\\]\nThis is just the usual binary representation of integers, but with qubits. I like to refer to \\(|a\\rangle\\) as the (standard) \\(n\\)-qubit representation of the integer \\(a\\)."
  },
  {
    "objectID": "posts/quantum-fourier-transform/index.html#proof-that-qft-satisfies-the-recursive-formula",
    "href": "posts/quantum-fourier-transform/index.html#proof-that-qft-satisfies-the-recursive-formula",
    "title": "Quantum Fourier transform",
    "section": "Proof that QFT satisfies the recursive formula",
    "text": "Proof that QFT satisfies the recursive formula\nTo prove the recursive formula 5 we compute the output of the recursive circuit on an arbitrary \\((n+1)\\)-qubit representation of an integer: \\(|a\\rangle=|a_na_{n-1}\\cdots a_0\\rangle\\). In doing so, it will continue to use the notation from Section 2.1.3 by writing \\[\n|a\\rangle=|a_n\\rangle\\otimes|a'\\rangle.\n\\tag{6}\\] Following 5, we first apply the Hadamard gate (which is \\(QFT_1\\)) to the first (top) qubit: \\[\n|a_n\\rangle\\otimes|a'\\rangle \\mapsto \\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i a_n b_0}|b_0\\rangle\\otimes|a'\\rangle.\n\\] Next, (according to 5) we apply the CPC-gate to the result and use 4 to get \\[\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i b_0 a_n}|b_0\\rangle\\otimes|a'\\rangle\\mapsto \\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\pi i b_0 a_n}e^{\\frac{\\pi i b_0 a'}{2^n}}|b_0\\rangle\\otimes|a'\\rangle.\n\\tag{7}\\] Since \\[\n2^na_n + a'=a\n\\tag{8}\\] (which follows from 6), the exponentials in the output of 7 can be simplified as follows: \\[\ne^{\\pi i b_0 a_n}e^{\\frac{\\pi i b_0 a'}{2^n}}=e^{\\frac{\\pi i b_0(2^na_n+a')}{2^n}}=e^{\\frac{\\pi i b_0 a}{2^n}}\n\\] Thus, the output of 7 can be written as \\[\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes|a'\\rangle.\n\\] Next, (according to 5) we apply the QFT-gate to the last (bottom) \\(n\\) qubits using 1: \\[\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes|a'\\rangle\n\\mapsto\n\\dfrac{1}{\\sqrt{2}}\\sum_{0\\leq b_0\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}|b_0\\rangle\\otimes\\dfrac{1}{\\sqrt{2^n}}\\sum_{0\\leq b'<2^n}e^{\\frac{2\\pi i a'b'}{2^n}}|b'\\rangle.\n\\] If we write \\(|b'\\rangle=|b_nb_{n-1}\\cdots b_1\\rangle\\), then the output above can be written as \\[\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0\\rangle\\otimes|b_n\\cdots b_1\\rangle.\n\\] Now, (still following 5) we reverse the last (bottom) \\(n\\) qubits to get\n\\[\\begin{align*}\n& \\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0\\rangle\\otimes|b_1\\cdots b_n\\rangle \\\\\n& =\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i b_0 a}{2^n}}e^{\\frac{2\\pi i a'b'}{2^n}}|b_0b_1\\cdots b_n\\rangle. \\\\\n& =\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,b_1,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b_0b_1\\cdots b_n\\rangle.\n\\end{align*} \\tag{9}\\]\nFinally, if we let \\(b\\) denote the integer with \\(|b\\rangle=|b_n\\cdots b_0\\rangle\\), then after we reverse all \\(n+1\\) qubits (the last step in 5) in 9 we get \\[\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{0\\leq b_0,\\ldots,b_n\\leq 1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b_n\\cdots b_0\\rangle\n=\n\\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{b=0}^{2^{n+1}-1}e^{\\frac{\\pi i (ab_0+2a'b')}{2^n}}|b\\rangle.\n\\] The state above the output of the recursive gate 5 applied to \\(|a\\rangle\\). On the other hand, using 1 we get \\[\nQFT_{n+1}|a\\rangle = \\dfrac{1}{\\sqrt{2^{n+1}}}\\sum_{b=0}e^{2^{n+1}-1}e^{\\frac{2\\pi i ab}{2^{n+1}}}|b\\rangle.\n\\] Thus, to complete the proof it suffices to show \\[\ne^{\\frac{\\pi i (ab_0+2a'b')}{2^n}} = e^{\\frac{2\\pi i ab}{2^{n+1}}}\n\\] or equivalently \\[\ne^{\\frac{\\pi i (ab-ab_0-2a'b')}{2^{n}}} = 1.\n\\]\nSince \\(|b\\rangle=|b_n\\cdots b_1b_0\\rangle\\) and \\(|b'\\rangle=|b_n\\cdots b_1\\rangle\\), it follows that \\(b=2b'+b_0\\) so that \\(b-b_0=2b'\\). Using this fact along with \\(a-a'=2^na_n\\) (which follows from 8) we get the desired result: \\[\\begin{align*}\ne^{\\frac{\\pi i (ab-ab_0-2a'b')}{2^{n}}}\n& = e^{\\frac{\\pi i (2ab'-2a'b')}{2^{n}}} \\\\\n& = e^{\\frac{\\pi i (2(a-a')b')}{2^{n}}} \\\\\n& = e^{\\frac{\\pi i (2^{n+1}a_nb')}{2^{n}}}\\\\\n& = e^{2\\pi i a_nb'}\\\\\n& = 1.\n\\end{align*}\\]"
  }
]