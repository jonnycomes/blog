{
  "hash": "a4b8a4760b546ddf3374deadc1cd66cd",
  "result": {
    "markdown": "---\ntitle: 'Qiskit: getting started'\nauthor: Jonny Comes\ndate: '2022-11-28'\ncategories:\n  - quantum\n  - qiskit\ndraft: false\ntoc: true\n---\n\nQiskit is an open source software development kie (SDK) for working with quantum computation. There are several excellent tutorials for getting started with qiskit, as well as loads of great documentation you can find at [qiskit.org](https://qiskit.org). The following walks through some of the very basics including how to create quantum circuits, simulate measurments, and work with state vectors. \n\n## Creating quantum circuits\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nfrom qiskit import QuantumCircuit\n```\n:::\n\n\nFirst, we create a 3-qubit quantum circuit:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nqc = QuantumCircuit(3)\n```\n:::\n\n\nNext, we add some gates and draw the resulting circuit:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nqc.x(0)\nqc.h(2)\nqc.cx(0,2)\nqc.cx(1,2)\nqc.draw()\n```\n\n::: {.cell-output .cell-output-display execution_count=66}\n```{=html}\n<pre style=\"word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace\">     ┌───┐          \nq_0: ┤ X ├──■───────\n     └───┘  │       \nq_1: ───────┼────■──\n     ┌───┐┌─┴─┐┌─┴─┐\nq_2: ┤ H ├┤ X ├┤ X ├\n     └───┘└───┘└───┘</pre>\n```\n:::\n:::\n\n\n## Measurements\n\nWe can simulate a measurement, but first we need to import a simulator:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfrom qiskit.providers.aer import QasmSimulator\n\nsimulator = QasmSimulator()\n```\n:::\n\n\n### Measure using a classical register explicitly \n\nOne way to measure is to use a circuit having both a quantum and classical register:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ncircuit = QuantumCircuit(3, 3)\n```\n:::\n\n\nNow, let's add some gates including some measuments:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.cx(0, 2)\ncircuit.measure([0,1,2], [0,1,2])\ncircuit.draw()\n```\n\n::: {.cell-output .cell-output-display execution_count=69}\n```{=html}\n<pre style=\"word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace\">     ┌───┐             ┌─┐   \nq_0: ┤ H ├──■────■─────┤M├───\n     └───┘┌─┴─┐  │  ┌─┐└╥┘   \nq_1: ─────┤ X ├──┼──┤M├─╫────\n          └───┘┌─┴─┐└╥┘ ║ ┌─┐\nq_2: ──────────┤ X ├─╫──╫─┤M├\n               └───┘ ║  ║ └╥┘\nc: 3/════════════════╩══╩══╩═\n                     1  0  2 </pre>\n```\n:::\n:::\n\n\nNext, we simulate and count the results:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\njob = simulator.run(circuit, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circuit)\nprint(counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'000': 496, '111': 504}\n```\n:::\n:::\n\n\nWe can plot the results using qiskits built in visualization:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfrom qiskit.visualization import plot_histogram\n\nplot_histogram(counts)\n```\n\n::: {.cell-output .cell-output-display execution_count=71}\n![](index_files/figure-html/cell-9-output-1.png){width=608 height=431}\n:::\n:::\n\n\n### Using the ``measure_all()`` method\n\nAlternatively, if we want to measure all the qubits we can use the ``measure_all()`` method:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ncircuit = QuantumCircuit(3)\n```\n:::\n\n\nNow, let's add some gates including some measuments:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.cx(0, 2)\ncircuit.measure_all()\ncircuit.draw()\n```\n\n::: {.cell-output .cell-output-display execution_count=73}\n```{=html}\n<pre style=\"word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace\">        ┌───┐           ░ ┌─┐      \n   q_0: ┤ H ├──■────■───░─┤M├──────\n        └───┘┌─┴─┐  │   ░ └╥┘┌─┐   \n   q_1: ─────┤ X ├──┼───░──╫─┤M├───\n             └───┘┌─┴─┐ ░  ║ └╥┘┌─┐\n   q_2: ──────────┤ X ├─░──╫──╫─┤M├\n                  └───┘ ░  ║  ║ └╥┘\nmeas: 3/═══════════════════╩══╩══╩═\n                           0  1  2 </pre>\n```\n:::\n:::\n\n\nWe should see similar results:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\njob = simulator.run(circuit, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circuit)\nprint(counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'000': 483, '111': 517}\n```\n:::\n:::\n\n\nOf course, this will only work if we want to measure all the qubits in the output state of the circuit. \n\n## Circuit orientation\n\nQiskit orients circuits so that the qubits $q_0, q_1,\\ldots, q_{n-1}$ labelling the circut from top to bottom correspond to the input state $|q_{n-1}\\cdots q_1q_0\\rangle$. To see this, let's create a simple gate that maps $|000\\rangle\\mapsto|100\\rangle$. \n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ncirc = QuantumCircuit(3)\ncirc.x(2)\ncirc.measure_all()\ncirc.draw()\n```\n\n::: {.cell-output .cell-output-display execution_count=75}\n```{=html}\n<pre style=\"word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace\">              ░ ┌─┐      \n   q_0: ──────░─┤M├──────\n              ░ └╥┘┌─┐   \n   q_1: ──────░──╫─┤M├───\n        ┌───┐ ░  ║ └╥┘┌─┐\n   q_2: ┤ X ├─░──╫──╫─┤M├\n        └───┘ ░  ║  ║ └╥┘\nmeas: 3/═════════╩══╩══╩═\n                 0  1  2 </pre>\n```\n:::\n:::\n\n\nTo see that the circuit above does the trick, let's measure:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\njob = simulator.run(circ, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circ)\nprint(counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'100': 1000}\n```\n:::\n:::\n\n\nI prefer the flipped orientation where the top qubit in the circuit corresponds to the left qubit in the tensor product. To have qiskit draw circuits with my prefered orientation, we simply pass ``reverse_bits=True`` to the ``draw()`` method:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ncirc.draw(reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=77}\n```{=html}\n<pre style=\"word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace\">        ┌───┐ ░       ┌─┐\n   q_2: ┤ X ├─░───────┤M├\n        └───┘ ░    ┌─┐└╥┘\n   q_1: ──────░────┤M├─╫─\n              ░ ┌─┐└╥┘ ║ \n   q_0: ──────░─┤M├─╫──╫─\n              ░ └╥┘ ║  ║ \nmeas_2: ═════════╬══╬══╩═\n                 ║  ║    \nmeas_1: ═════════╬══╩════\n                 ║       \nmeas_0: ═════════╩═══════\n                         </pre>\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\njob = simulator.run(circ, shots=1000)\nresult = job.result()\ncounts = result.get_counts(circ)\nprint(counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'100': 1000}\n```\n:::\n:::\n\n\n## State vectors and Bloch spheres\n\nWe can use qiskits ``Statevector`` object work with $n$-qubit states.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nfrom qiskit.quantum_info import Statevector\n```\n:::\n\n\n For example, the following creates the state $|7\\rangle$ for a 4-qubit register:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nstate = Statevector.from_int(7, 2**4)\nstate.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=80}\n$$ |0111\\rangle$$\n:::\n:::\n\n\nWe can visualize the state $|7\\rangle$ on a register of Bloch spheres as follows:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nfrom qiskit.visualization import plot_bloch_multivector\n\nplot_bloch_multivector(state, reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=81}\n![](index_files/figure-html/cell-19-output-1.png){width=1210 height=305}\n:::\n:::\n\n\nWe can run this state through a quantum circuit as in the following example:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nqc = QuantumCircuit(4)\nqc.h(1)\nqc.h(2)\nqc.cx(0, 2)\nqc.swap(1,3)\nqc.draw(reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=82}\n```{=html}\n<pre style=\"word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace\">                  \nq_3: ───────────X─\n     ┌───┐┌───┐ │ \nq_2: ┤ H ├┤ X ├─┼─\n     ├───┤└─┬─┘ │ \nq_1: ┤ H ├──┼───X─\n     └───┘  │     \nq_0: ───────■─────\n                  </pre>\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nstate = state.evolve(qc)\nstate.draw('latex')\n```\n\n::: {.cell-output .cell-output-display execution_count=83}\n$$- \\frac{1}{2} |0001\\rangle+\\frac{1}{2} |0101\\rangle+\\frac{1}{2} |1001\\rangle- \\frac{1}{2} |1101\\rangle$$\n:::\n:::\n\n\nFinally, let's look at this state using Bloch spheres:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nplot_bloch_multivector(state, reverse_bits=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=84}\n![](index_files/figure-html/cell-22-output-1.png){width=1210 height=305}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}